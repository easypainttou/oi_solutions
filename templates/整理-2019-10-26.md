# note
## 部分板子
``` c
/*
ac自动机
loj-10057
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=5e5+10;
const int maxm=1e6+10;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

struct node{
	int dic[26],fail,bk;
}ac[maxn];
char str[55],str2[maxm];
int T,n,tot;

void insertTrie(){
	int len=strlen(str),now=0;
	for(int i=0;i<len;i++){
		int c=str[i]-'a';
		if(ac[now].dic[c]==0)ac[now].dic[c]=++tot;
		now=ac[now].dic[c];
	}
	ac[now].bk++;
}

void getFail(){
	queue<int>q;
	for(int i=0;i<26;i++){
		if(ac[0].dic[i])ac[ac[0].dic[i]].fail=0,q.push(ac[0].dic[i]);
	}
	
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=0;i<26;i++){
			if(ac[now].dic[i]){
				ac[ac[now].dic[i]].fail=ac[ac[now].fail].dic[i];
				q.push(ac[now].dic[i]);
			}
			else ac[now].dic[i]=ac[ac[now].fail].dic[i];
		}
	}
}

int getAns(){
	int now=0,ans=0,len=strlen(str2);
	for(int i=0;i<len;i++){
		int c=str2[i]-'a';
		now=ac[now].dic[c];
		for(int j=now;j;j=ac[j].fail){
			ans+=ac[j].bk;
			ac[j].bk=0;//wa...
		}
	}
	return ans;
}

void solve(){
	scanf("%d",&T);
	while(T--){
		tot=0;
		memset(ac,0,sizeof(ac));
		
		scanf("%d",&n);
		while(n--){
			scanf("%s",str);
			insertTrie();
		}
		getFail();
		scanf("%s",str2);
		printf("%d\n",getAns());
	}
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
k短路 a*
POJ-2449
*/
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=1e3+10;
const int maxm=1e5+10;

struct node{
	int u,g;
	node(int u,int g):u(u),g(g){}
};
struct edge{
	int v,w,next;
}es[maxm],rEs[maxm];
int n,m,s,t,k,tot,head[maxn],rHead[maxn],dis[maxn];
bool vis[maxn];

bool operator<(const node&a,const node&b){
	int fa=a.g+dis[a.u],fb=b.g+dis[b.u];
	if(fa==fb)return a.g>b.g;	//要这样比较，不然WA。。
	return fa>fb;
}

int read(){
	int f=1,res=0;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())res=res*10+ch-'0';
	return res*f;
}

inline void addEdge(int u,int v,int w){
	es[++tot].v=v,es[tot].w=w,es[tot].next=head[u],head[u]=tot;
	rEs[tot].v=u,rEs[tot].w=w,rEs[tot].next=rHead[v],rHead[v]=tot;//反向加边，最短路需要
}

void dijkstra(){//跑的是反向边qwq
	priority_queue< pair<int,int> >q;
	memset(dis,0x3f,sizeof(dis));
	dis[t]=0;
	q.push(make_pair(0,t));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=rHead[u];i;i=rEs[i].next){
			int v=rEs[i].v,w=rEs[i].w;
			if(vis[v])continue;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}

void aStar(){
	priority_queue<node>q;
	q.push(node(s,0));
	int cnt=0;
	if(s==t)++k;//WA点，qwq
	while(!q.empty()){
		node now=q.top();q.pop();
		int u=now.u;
		if(u==t)++cnt;
		if(cnt==k){
			printf("%d",now.g);
			return;
		}
		for(int i=head[u];i;i=es[i].next){
			int v=es[i].v,w=es[i].w;
			q.push(node(v,now.g+w));
		}
	}
	printf("-1");
}

void solve(){
	scanf("%d%d",&n,&m);
	int a,b,c;
	for(int i=1;i<=m;i++){
		a=read(),b=read(),c=read();
		addEdge(a,b,c);
	}
	scanf("%d%d%d",&s,&t,&k);
	dijkstra();
	aStar();
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
bfs-spfa
*/


void spfa(){
	queue<int>q;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	q.push(maxnum);
	dis[maxnum]=0;
	vis[maxnum]=1;
	while(!q.empty()){
		int now=q.front();q.pop();
		vis[now]=0;
		for(int i=head[now];i;i=es[i].next){
			int v=es[i].v,w=es[i].w;
			if(dis[v]>dis[now]+w){
				dis[v]=dis[now]+w;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	}
}
```
``` c
/*
组合数 lucas定理 crt 快速幂 逆元
BZOJ-1951
*/
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN=7e4;
const int MAXM=(1<<9)+10;
const int MOD=999911659;

//lucas定理中，p为质数，999911658不是质数，所以要分解为2,3,4679,35617，就能使用lucas，然后用一下crt...
ll N,G,ps[]={2,3,4679,35617},a[4],fac[MAXN];

void init(){
	fac[0]=1;
	for(int i=1;i<=ps[3];i++)fac[i]=fac[i-1]*i%(MOD-1);
}

ll qPow(ll a,ll b,ll p){
	ll res=1;
	while(b){
		if(b&1)res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}

ll getC(ll n,ll m,ll p){
	if(n<m)return 0; //一直wa在这，qwq
	ll inv=qPow(fac[m]*fac[n-m]%p,p-2,p);
	return inv*fac[n]%p;
}

ll lucas(ll n,ll m,ll p){
	if(!m)return 1;
	return getC(n%p,m%p,p)*lucas(n/p,m/p,p)%p;
}

ll crt(){
	ll res=0,M=MOD-1;
	for(int i=0;i<4;i++){
		ll mi=M/ps[i],inv=qPow(mi,ps[i]-2,ps[i]);
		res=(res+mi*inv%M*a[i]%M)%M;
	}
	return res;
}

void solve(){
	scanf("%lld%lld",&N,&G);
	if(G%MOD==0){puts("0");return;} //wa在这，qwq
	init();
	for(int i=1;i*i<=N;i++){
		if(N%i==0){
			for(int j=0;j<4;j++)
				a[j]=(a[j]+lucas(N,i,ps[j]))%ps[j];
			if(i!=N/i)
				for(int j=0;j<4;j++)
					a[j]=(a[j]+lucas(N,N/i,ps[j]))%ps[j];
		}
	}
	printf("%lld",qPow(G,crt(),MOD));
}

int main(){
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	solve();
	return 0;
}
```

``` c
/*
dfs-spfa
找环
0 无环
1 有环
*/


bool spfa(int x,double mid){
	vis[x]=1;
	for(int i=head[x];i;i=es[i].next){
		int v=es[i].v;
		double w=es[i].w;
		if(dis[v]<dis[x]+w-mid){
			dis[v]=dis[x]+w-mid;
			if(vis[v])return 1;
			if(spfa(v,mid))return 1;
		}
	}
	vis[x]=0;
	return 0;
}
```

``` c
/*
dijkstra
poj-2387
*/


struct edge{
	int v,w,next;
}es[maxm];
int T,N,head[maxn],tot,dis[maxn];
bool vis[maxn];

void addEdge(int u,int v,int w){
	es[++tot].v=v,es[tot].w=w,es[tot].next=head[u],head[u]=tot;
}

void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0;
	priority_queue< pair<int,int> >q;
	q.push(make_pair(0,1));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=es[i].next){
			int v=es[i].v,w=es[i].w;
			if(!vis[v]&&dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}

void solve(){
	scanf("%d%d",&T,&N);
	for(int i=1;i<=T;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		addEdge(x,y,z),addEdge(y,x,z);
	}
	dijkstra();
	printf("%d",dis[N]);
}
```
``` c
/*
source:oi-wiki

dinic
*/

#define maxn 250
#define INF 0x3f3f3f3f

struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

struct Dinic {
  int n, m, s, t;
  vector<Edge> edges;
  vector<int> G[maxn];
  int d[maxn], cur[maxn];
  bool vis[maxn];

  void init(int n) {
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(s);
    d[s] = 0;
    vis[s] = 1;
    while (!Q.empty()) {
      int x = Q.front();
      Q.pop();
      for (int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if (!vis[e.to] && e.cap > e.flow) {
          vis[e.to] = 1;
          d[e.to] = d[x] + 1;
          Q.push(e.to);
        }
      }
    }
    return vis[t];
  }

  int DFS(int x, int a) {
    if (x == t || a == 0) return a;
    int flow = 0, f;
    for (int& i = cur[x]; i < G[x].size(); i++) {
      Edge& e = edges[G[x][i]];
      if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
        e.flow += f;
        edges[G[x][i] ^ 1].flow -= f;
        flow += f;
        a -= f;
        if (a == 0) break;
      }
    }
    return flow;
  }

  int Maxflow(int s, int t) {
    this->s = s;
    this->t = t;
    int flow = 0;
    while (BFS()) {
      memset(cur, 0, sizeof(cur));
      flow += DFS(s, INF);
    }
    return flow;
  }
};
```
``` c
/*

...欧拉回路板子
loj-10105

*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=4e5+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

struct edge{
	int v,next;
}es[maxm];
int t,n,m,tot=1,head[maxn],in[maxn],out[maxn];
bool vis[maxm];
vector<int>ans;


inline void addEdge(int u,int v){
	es[++tot].v=v,es[tot].next=head[u],head[u]=tot;
}

void dfs(int u){
	for(int &i=head[u];i;i=es[i].next){ //要引用，不然T，QAQ
		int e=((t==1)?(i/2):(i-1));
		int flag=((i&1)?(-1):(1));
		if(vis[e])continue;
		vis[e]=1;
		dfs(es[i].v);
		if(t==1)ans.push_back(flag*e);
		else ans.push_back(e);
	}
}

void solve(){
	scanf("%d%d%d",&t,&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		addEdge(u,v);
		if(t==1)addEdge(v,u);
		++out[u],++in[v];
	}
	if(t==1){
		for(int i=1;i<=n;i++){
			if((in[i]+out[i]&1)==1){
				printf("NO");return;
			}
		}
	}else{
		for(int i=1;i<=n;i++){
			if(in[i]!=out[i]){
				printf("NO");return;
			}
		}
	}
	for(int i=1;i<=n;i++)if(head[i]){dfs(i);break;}
	if(ans.size()!=m){printf("NO");return;}
	else{
		printf("YES\n");
		for(int i=m-1;i>=0;i--)printf("%d ",ans[i]);
	}
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
扩展中国剩余定理 板子题
HDU-3579
*/

#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long LL;

const int MAX_N = 400 + 10;
const int MAX_M = 40000 + 10;
const int INF = 0x3f3f3f3f;

LL n, m[10], a[10];

LL exgcd(LL a, LL b, LL& x, LL& y) {
	if (b == 0) {
		x = 1, y = 0;
		return a;
	}
	LL g = exgcd(b, a % b, y, x);
	y -= a / b * x;
	return g;
}

LL excrt() {
	LL M = m[1], X = a[1];
	for (LL i = 2; i <= n; i++) {
		LL c = ((a[i] - X) % m[i] +m[i]) % m[i], x, y, g = exgcd(M, m[i], x, y);
		if (c % g) {
			return -1;
		}
		LL p = m[i] / g;
		x = x * c / g % p;
		X += x * M;
		M *= p;
		X = (X % M + M) % M;
	}
	if (X == 0) X += M; //wa点，输出最小正整数，没有这个就是最小非负整数
	return X;
}

void solve() {
	LL T;
	scanf("%lld", &T);
	for (LL kase = 1; kase <= T; kase++) {
		scanf("%lld", &n);
		for (int i = 1; i <= n; i++) scanf("%d", m + i);
		for (int i = 1; i <= n; i++) scanf("%d", a + i);
		printf("Case %lld: %lld\n", kase, excrt());
	}
}

int main() {
	//ios::sync_with_stdio(false);
	//freopen("in.txt", "r", stdin);
	solve();
	return 0;
}
```
``` c
/*
source:oi-wiki

z算法
*/

vector<int> z_function(string s) {
  int n = (int)s.length();
  vector<int> z(n);
  for (int i = 1, l = 0, r = 0; i < n; ++i) {
    if (i <= r) z[i] = min(r - i + 1, z[i - l]);
    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
  }
  return z;
}
```

``` c
/*
给定一张无向图，求图中一个至少包含  3个点的环，环上的节点不重复，并且环上的边的长度之和最小。该问题称为无向图的最小环问题。在本题中，你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。若无解，输出 No solution.

floyd 最小环
loj-10072
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=105;
const int maxm=105;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

int n,m,g[maxn][maxn],d[maxn][maxn],path[maxn][maxn];
vector<int>ap;

void getPath(int i,int j){
	int now=path[i][j];
	if(now==0)return;
	getPath(i,now);
	ap.push_back(now);
	getPath(now,j);
}

void floyd(){
	int ans=inf;
	for(int k=1;k<=n;k++){
		for(int i=1;i<k;i++){
			for(int j=i+1;j<k;j++){
				if(ans>(ll)d[i][j]+g[j][k]+g[k][i]){
					ans=d[i][j]+g[j][k]+g[k][i];
					ap.clear();
					ap.push_back(i);
					getPath(i,j);
					ap.push_back(j);
					ap.push_back(k);
				}
			}
		}
		
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(d[i][j]>d[i][k]+d[k][j]){
					d[i][j]=d[i][k]+d[k][j];
					path[i][j]=k;
				}
			}
		}
	}
}

void solve(){
	int x,y,z;
	memset(g,0x3f,sizeof(g));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)g[i][i]=0;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		g[y][x]=g[x][y]=min(g[x][y],z);
	}
	memcpy(d,g,sizeof(g));
	floyd();
	if(ap.size()==0)printf("No solution.");
	else for(int i=0;i<ap.size();i++)printf("%d ",ap[i]);
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
高斯消元板子 qwq
系数矩阵a 增广矩阵A
无解 r(a)<r(A)
唯一 r(a)=r(A)=n
无穷 r(a)=r(A)<n
自由元看某一列是否全是0
*/

#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int MAX_N = 100 + 5;
const int INF = 0x3f3f3f3f;
const double EPS = 1e-6;

int n;
double a[MAX_N][MAX_N], ans[MAX_N];

//0-无解 1-唯一 2-无穷
int gauss() {
	int rank = n, now = 1;
	for (int i = 1; i <= n; ++i) {
		int r = now;
		for (int j = now + 1; j <= n; ++j) {
			if (fabs(a[j][i]) > fabs(a[r][i])) r = j;
		}
		if (fabs(a[r][i]) < EPS) {
			--rank;
			continue;
		}
		if (r != now) swap(a[now], a[r]);
		double div = a[now][i];
		for (int j = i; j <= n + 1; ++j) {
			a[now][j] /= div;
		}
		for (int j = now + 1; j <= n; ++j) {
			div = a[j][i];
			for (int k = i; k <= n + 1; ++k) {
				a[j][k] -= div * a[now][k];
			}
		}
		++now;
	}
	for (int i = rank + 1; i <= n; ++i) {
		if (fabs(a[i][n + 1]) > EPS) return 0; 
	}
	if (rank < n) {
		return 2;
	}
	for (int i = n; i >= 1; --i) {
		ans[i] = a[i][n + 1];
		for (int j = i + 1; j <= n; ++j) {
			ans[i] -= ans[j] * a[i][j];
		}
	}
	return 1;
}

void solve() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n + 1; ++j) {
			scanf("%lf", &a[i][j]);
		}
	}
	int stt = gauss();
	if(stt == 1)for (int i = 1; i <= n; ++i) printf("%.2f\n", ans[i]);
	else if (stt == 2) printf("No Solution");
}

int main() {
//	freopen("in.txt", "r", stdin);
	solve();
	return 0;
}
```

``` c
/*
hamilton路径 dp
ch-0103
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e2+5;
const int maxm=1e3+5;
const int inf=0x3f3f3f3f;
typedef long long ll;

int n,g[20][20],f[1<<20][20];

void hamilton(){
	memset(f,0x3f,sizeof(f));
	f[1][0]=0;
	for(int i=0;i<1<<n;i++){
		for(int j=0;j<n;j++){
			if(i>>j&1){
				for(int k=0;k<n;k++){
					int stt=i^1<<j;
					if(stt>>k&1){
						f[i][j]=min(f[i][j],f[stt][k]+g[k][j]);
					}
				}
			}
		}
	}
}

void solve(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			scanf("%d",&g[i][j]);
	hamilton();
	printf("%d",f[(1<<n)-1][n-1]);
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
树链剖分
luogu-3384
*/
#include<bits/stdc++.h>
#define lson p<<1
#define rson p<<1|1
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=1e6+5;
const double eps=1e-10;
const int base=131;
//const int mod=1e9+7;



struct edge{
	int v,next;
}es[2*maxn];
int n,m,r,mod,pw[maxn],head[maxn],tot,cnt,dep[maxn],fa[maxn],size[maxn],son[maxn],id[maxn],w[maxn],top[maxn],tree[4*maxn],b[4*maxn];

int read(){
	int ans=0,f=1;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())ans=ans*10+ch-'0';
	return ans*f;
}

inline void addEdge(int u,int v){
	es[++tot].v=v,es[tot].next=head[u],head[u]=tot;
}

void build(int l,int r,int p){
	if(l==r){
		tree[p]=w[l]%mod;
		return;
	}
	int m=(l+r)>>1;
	build(l,m,lson),build(m+1,r,rson);
	tree[p]=(tree[lson]+tree[rson])%mod;
}

inline void pushdown(int s,int t,int m,int p){
	if(s!=t&&b[p]){
		tree[lson]=(tree[lson]+b[p]*(m-s+1)%mod)%mod,tree[rson]=(tree[rson]+b[p]*(t-m)%mod)%mod;
		b[lson]=(b[lson]+b[p])%mod,b[rson]=(b[rson]+b[p])%mod;
	}
	b[p]=0;
}

void update(int l,int r,int c,int s,int t,int p){
	if(l<=s&&t<=r){
		tree[p]=(tree[p]+c*(t-s+1)%mod)%mod;
		b[p]=(b[p]+c)%mod;
		return;
		
	}
	
	int m=(s+t)>>1;
	pushdown(s,t,m,p);
	if(l<=m)update(l,r,c,s,m,lson);
	if(r>m)update(l,r,c,m+1,t,rson);
	tree[p]=(tree[lson]+tree[rson])%mod;
}

int query(int l,int r,int s,int t,int p){
	if(l<=s&&t<=r){
		return tree[p];
	}
	int m=(s+t)>>1,ans=0;
	pushdown(s,t,m,p);
	if(l<=m)ans=(ans+query(l,r,s,m,lson))%mod;
	if(r>m)ans=(ans+query(l,r,m+1,t,rson))%mod;
	return ans;
}

void dfs1(int x,int f){
	dep[x]=dep[f]+1,fa[x]=f;
	size[x]=1;
	int maxnum=0;
	for(int i=head[x];i;i=es[i].next){
		int v=es[i].v;
		if(v==f)continue;
		dfs1(v,x);
		size[x]+=size[v];
		if(size[v]>maxnum)maxnum=size[v],son[x]=v;
	}
}

void dfs2(int x,int t){
	id[x]=++cnt;
	w[id[x]]=pw[x];
	top[x]=t;
	if(!son[x])return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=es[i].next){
		int v=es[i].v;
		if(v==fa[x]||v==son[x])continue;
		dfs2(v,v);
	}
}

void updRange(int x,int y,int c){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(id[top[x]],id[x],c,1,n,1);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	update(id[y],id[x],c,1,n,1);
}

int qRange(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=(ans+query(id[top[x]],id[x],1,n,1))%mod;
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	ans=(ans+query(id[y],id[x],1,n,1))%mod;
	return ans;
}

void updSon(int x,int c){
	update(id[x],id[x]+size[x]-1,c,1,n,1);
}

int qSon(int x){
	return query(id[x],id[x]+size[x]-1,1,n,1);
}

void solve(){
	scanf("%d%d%d%d",&n,&m,&r,&mod);
	for(int i=1;i<=n;i++)pw[i]=read();
	int x,y;
	for(int i=1;i<=n-1;i++)x=read(),y=read(),addEdge(y,x),addEdge(x,y);
	dfs1(r,0),dfs2(r,r),build(1,n,1);
	while(m--){
		int x=read(),y=read();
		if(x==1){
			int z=read(),w=read();
			updRange(y,z,w);
		}else if(x==2){
			int z=read();
			printf("%d\n",qRange(y,z));
		}else if(x==3){
			int z=read();
			updSon(y,z);
		}else if(x==4){
			printf("%d\n",qSon(y));
		}
	}
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
source:oi-wiki

hlpp
*/

#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int N = 1e4 + 4, M = 2e5 + 5, INF = 0x3f3f3f3f;
int n, m, s, t;

struct qxx {
  int nex, t, v;
};
qxx e[M * 2];
int h[N], cnt = 1;
void add_path(int f, int t, int v) { e[++cnt] = (qxx){h[f], t, v}, h[f] = cnt; }
void add_flow(int f, int t, int v) {
  add_path(f, t, v);
  add_path(t, f, 0);
}

int ht[N], ex[N], gap[N];  // 高度；超额流；gap 优化
bool bfs_init() {
  memset(ht, 0x3f, sizeof(ht));
  queue<int> q;
  q.push(t), ht[t] = 0;
  while (q.size()) {  // 反向 BFS, 遇到没有访问过的结点就入队
    int u = q.front();
    q.pop();
    for (int i = h[u]; i; i = e[i].nex) {
      const int &v = e[i].t;
      if (e[i ^ 1].v && ht[v] > ht[u] + 1) ht[v] = ht[u] + 1, q.push(v);
    }
  }
  return ht[s] != INF;  // 如果图不连通，返回 0
}
struct cmp {
  bool operator()(int a, int b) const { return ht[a] < ht[b]; }
};                                         // 伪装排序函数
priority_queue<int, vector<int>, cmp> pq;  // 将需要推送的结点以高度高的优先
bool vis[N];                               // 是否在优先队列中
int push(int u) {  // 尽可能通过能够推送的边推送超额流
  for (int i = h[u]; i; i = e[i].nex) {
    const int &v = e[i].t, &w = e[i].v;
    if (!w || ht[u] != ht[v] + 1) continue;
    int k = min(w, ex[u]);  // 取到剩余容量和超额流的最小值
    ex[u] -= k, ex[v] += k, e[i].v -= k, e[i ^ 1].v += k;  // push
    if (v != s && v != t && !vis[v])
      pq.push(v), vis[v] = 1;  // 推送之后，v 必然溢出，则入堆，等待被推送
    if (!ex[u]) return 0;  // 如果已经推送完就返回
  }
  return 1;
}
void relabel(int u) {  // 重贴标签（高度）
  ht[u] = INF;
  for (int i = h[u]; i; i = e[i].nex)
    if (e[i].v) ht[u] = min(ht[u], ht[e[i].t]);
  ++ht[u];
}
int hlpp() {                  // 返回最大流
  if (!bfs_init()) return 0;  // 图不连通
  ht[s] = n;
  memset(gap, 0, sizeof(gap));
  for (int i = 1; i <= n; i++)
    if (ht[i] != INF) gap[ht[i]]++;  // 初始化 gap
  for (int i = h[s]; i; i = e[i].nex) {
    const int v = e[i].t, w = e[i].v;  // 队列初始化
    if (!w) continue;
    ex[s] -= w, ex[v] += w, e[i].v -= w, e[i ^ 1].v += w;  // 注意取消 w 的引用
    if (v != s && v != t && !vis[v]) pq.push(v), vis[v] = 1;  // 入队
  }
  while (pq.size()) {
    int u = pq.top();
    pq.pop(), vis[u] = 0;
    while (push(u)) {  // 仍然溢出
      // 如果 u 结点原来所在的高度没有结点了，相当于出现断层
      if (!--gap[ht[u]])
        for (int i = 1; i <= n; i++)
          if (i != s && i != t && ht[i] > ht[u] && ht[i] < n + 1) ht[i] = n + 1;
      relabel(u);
      ++gap[ht[u]];  // 新的高度，更新 gap
    }
  }
  return ex[t];
}
int main() {
  scanf("%d%d%d%d", &n, &m, &s, &t);
  for (int i = 1, u, v, w; i <= m; i++) {
    scanf("%d%d%d", &u, &v, &w);
    add_flow(u, v, w);
  }
  printf("%d", hlpp());
  return 0;
}
```

``` c
/*
去掉res相关代码，就是一个普通埃及分数问题qwq
ida* 埃及分数 set
UVA-12558
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e3+5;

ll a,b,k,dep,v[maxn],ans[maxn];
set<int>res;

ll gcd(ll a,ll b){
	return b==0?a:gcd(b,a%b);
}

inline ll get(ll a,ll b){
	return b/a+1;
}

bool better(){
	for(ll i=dep;i>=0;i--){
		if(ans[i]!=v[i]){
			return v[i]<ans[i] || ans[i]==-1;
		}
	}
	return 0;
}


bool dfs(ll step,ll minn,ll a,ll b){
	if(step==dep){
		if(b%a==0){
			if(res.count(b/a))return 0;
			v[step]=b/a;
			if(better())memcpy(ans,v,sizeof(v));
			return 1;
		}
		return 0;
	}
	bool ok=0;
	minn=max(minn,get(a,b));
	for(ll i=minn;;i++){
		if(res.count(i))continue;
		if(b*(dep-step+1)<=a*i)break;
		ll aa=a*i-b,bb=b*i,g=gcd(aa,bb);
		v[step]=i;
		if(dfs(step+1,i+1,aa/g,bb/g))ok=1;
	}
	return ok;
}

void solve(){
	int t;
	scanf("%d",&t);
	for(int j=1;j<=t;j++){
		res.clear();
		scanf("%d%d%d",&a,&b,&k);
		int x;
		for(int i=1;i<=k;i++)scanf("%d",&x),res.insert(x);
		for(dep=1;;dep++){
			memset(ans,0xff,sizeof(ans));
			
			if(dfs(0,get(a,b),a,b)){
				
				printf("Case %d: %lld/%lld=",j,a,b);
				for(ll i=0;i<=dep;i++){
					if(i)printf("+");
					printf("1/%lld",ans[i]);
				}
				puts("");
				break;
			}
		}
	}
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
source:oi-wiki

isap
*/

struct Edge {
  int from, to, cap, flow;
  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};

bool operator<(const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}

struct ISAP {
  int n, m, s, t;
  vector<Edge> edges;
  vector<int> G[maxn];
  bool vis[maxn];
  int d[maxn];
  int cur[maxn];
  int p[maxn];
  int num[maxn];

  void AddEdge(int from, int to, int cap) {
    edges.push_back(Edge(from, to, cap, 0));
    edges.push_back(Edge(to, from, 0, 0));
    m = edges.size();
    G[from].push_back(m - 2);
    G[to].push_back(m - 1);
  }

  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(t);
    vis[t] = 1;
    d[t] = 0;
    while (!Q.empty()) {
      int x = Q.front();
      Q.pop();
      for (int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i] ^ 1];
        if (!vis[e.from] && e.cap > e.flow) {
          vis[e.from] = 1;
          d[e.from] = d[x] + 1;
          Q.push(e.from);
        }
      }
    }
    return vis[s];
  }

  void init(int n) {
    this->n = n;
    for (int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }

  int Augment() {
    int x = t, a = INF;
    while (x != s) {
      Edge& e = edges[p[x]];
      a = min(a, e.cap - e.flow);
      x = edges[p[x]].from;
    }
    x = t;
    while (x != s) {
      edges[p[x]].flow += a;
      edges[p[x] ^ 1].flow -= a;
      x = edges[p[x]].from;
    }
    return a;
  }

  int Maxflow(int s, int t) {
    this->s = s;
    this->t = t;
    int flow = 0;
    BFS();
    memset(num, 0, sizeof(num));
    for (int i = 0; i < n; i++) num[d[i]]++;
    int x = s;
    memset(cur, 0, sizeof(cur));
    while (d[s] < n) {
      if (x == t) {
        flow += Augment();
        x = s;
      }
      int ok = 0;
      for (int i = cur[x]; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if (e.cap > e.flow && d[x] == d[e.to] + 1) {
          ok = 1;
          p[e.to] = G[x][i];
          cur[x] = i;
          x = e.to;
          break;
        }
      }
      if (!ok) {
        int m = n - 1;
        for (int i = 0; i < G[x].size(); i++) {
          Edge& e = edges[G[x][i]];
          if (e.cap > e.flow) m = min(m, d[e.to]);
        }
        if (--num[d[x]] == 0) break;
        num[d[x] = m + 1]++;
        cur[x] = 0;
        if (x != s) x = edges[p[x]].from;
      }
    }
    return flow;
  }
};
```
``` c
/*
kmp / 字符串hash
loj-103
*/

//使用kmp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf=0x3f3f3f3f;
const int maxn=1e6+5;
const double eps=1e-10;
int next[maxn],n,m;
char a[maxn],b[maxn];
void kmp_pre(){
	int j=next[1]=0;
	for(int i=1;i<m;i++){
		while(j>0&&b[i+1]!=b[j+1])j=next[j];
		if(b[i+1]==b[j+1])j++;
		next[i+1]=j;
	}
}
int kmp(){
	int ans=0;
	for(int j=0,i=0;i<n;i++){
		while(j>0&&b[j+1]!=a[i+1])j=next[j];
		if(b[j+1]==a[i+1])j++;
		if(j==m){
			j=next[j];
			ans++;
		}
	}
	return ans;
}
void solve(){
	scanf("%s%s",a+1,b+1);
	n=strlen(a+1),m=strlen(b+1);
	kmp_pre();
	printf("%d",kmp());
}
int main(){
	//freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c

//使用hash


#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e6+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

int n,m,ans;
ll ah[maxn],bh,p[maxn];
char a[maxn],b[maxn];

void solve(){
	scanf("%s%s",a+1,b+1);
	n=strlen(a+1),m=strlen(b+1);
	p[0]=1;
	for(int i=1;i<=n;i++)ah[i]=(ah[i-1]*base+a[i]-'A'+1)%mod,p[i]=p[i-1]*base%mod;
	for(int i=1;i<=m;i++)bh=(bh*base+b[i]-'A'+1)%mod;
	for(int i=1;i+m-1<=n;i++)if(bh==(ah[i+m-1]-(ll)ah[i-1]*p[m]%mod+mod)%mod)ans++;
	printf("%d",ans);
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
倍增lca
loj-10130
*/

#include<bits/stdc++.h>
#define lson p<<1
#define rson p<<1|1
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=1e6+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

struct edge{
	int v,next;
}es[2*maxn];
int n,q,tot,head[maxn],fa[maxn][25],dep[maxn];

int read(){
	int ans=0,f=1;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())ans=ans*10+ch-'0';
	return ans*f;
}

inline void addEdge(int u,int v){
	es[++tot].v=v,es[tot].next=head[u],head[u]=tot;
}

void dfs(int u,int f){
	dep[u]=dep[f]+1;
	fa[u][0]=f;
	for(int i=1;i<=20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=head[u];i;i=es[i].next){
		int v=es[i].v;
		if(v==f)continue;
		dfs(v,u);
	}
}

int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;i>=0;i--){
		if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
		if(x==y)return x;
	}
	for(int i=20;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i],y=fa[y][i];
		}
	}
	return fa[x][0];
}

void solve(){
	n=read();
	int x,y;
	for(int i=1;i<=n-1;i++)x=read(),y=read(),addEdge(x,y),addEdge(y,x);
	dfs(1,0);
	q=read();
	while(q--){
		x=read(),y=read();
		printf("%d\n",dep[x]+dep[y]-2*dep[lca(x,y)]);
	}
	
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
最长回文子串 板子题
使用manacher实现时间复杂度O(n)

POJ-3974
*/

#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAX_N = 1e6 + 5;

int len, r[MAX_N << 1];
char s1[MAX_N], s2[MAX_N << 1];

void build() {
	int tot = 0;
	s2[tot++] = '@';
	for (int i = 0; i < len; ++i) {
		s2[tot++] = '#', s2[tot++] = s1[i];
	}
	s2[tot++] = '#', s2[tot++] = 0;
	len = tot;
}

int manacher() {
	build();
	int res = 0, maxR = 0, pos = 0;
	for (int i = 1; i <len; ++i) {
		r[i] = i < maxR ? min(r[(pos << 1) - i], maxR - i + 1) : 1;
		while (s2[i - r[i]] == s2[i + r[i]]) ++r[i];
		if (i + r[i] - 1 > maxR) {
			maxR = i + r[i] - 1;
			pos = i;
		}
		res = max(res, r[i] - 1);
	}
	return res;
}

void solve() {
	int kase = 0;
	while (1) {
		scanf("%s", s1);
		len = strlen(s1);
		if (len >= 3 && s1[0] == 'E' && s1[1] == 'N' && s1[2] == 'D') break;
		++kase;
		printf("Case %d: %d\n", kase,  manacher());
	}
}

int main() {
	//freopen("in.txt", "r", stdin);
	solve();
	return 0;
}
```
``` c
/*
mcmf
luogu-3381
被卡用dijkstra。。。抄别人的板子qwq

*/

#include <bits/stdc++.h>

#define inc(i, a, b) for (int i = a; i <= b; i++)

using namespace std;

const int MAX_N = 5e3 + 5;
const int MAX_M = 1e5 + 5;
const int INF = 0x3f3f3f3f;

struct Edge {
	int u, v, f, c, next;
} es[MAX_M];
int n, m, tot = 1, head[MAX_N], s, t, dis[MAX_N], flow[MAX_N], pre[MAX_N], maxF, minC;
bool vis[MAX_N];
queue<int> q;

inline void addEdge(int u, int v, int f, int c) {
	es[++tot].u = u, es[tot].v = v, es[tot].f = f, es[tot].c = c, es[tot].next = head[u], head[u] = tot;
}

inline void addPair(int u, int v, int f, int c) {
	addEdge(u, v, f, c);
	addEdge(v, u, 0, -c);
}

bool SPFA() {
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	while (q.size()) q.pop();
	dis[s] = 0;
	flow[s] = INF;
	flow[t] = 0;
	vis[s] = 1;
	q.push(s);
	while (q.size()) {
		int u = q.front(); q.pop();
		vis[u] = 0;
		for (int i = head[u]; i; i = es[i].next) {
			int & v = es[i].v, & f = es[i].f, & c = es[i].c;
			if (f > 0 && dis[v] > dis[u] + c) {
				flow[v] = min(f, flow[u]);
				dis[v] = dis[u] + c;
				pre[v] = i;
				if (!vis[v]) {
					vis[v] = 1;
					q.push(v);
				}
			}
		}
	}
	return flow[t];
}

void MCMF() {
	while (SPFA()) {
		int u = t;
		maxF += flow[t];
		minC += dis[t] * flow[t];
		while (u != s) { 
			es[pre[u]].f -= flow[t];
			es[pre[u]^1].f += flow[t];
			u = es[pre[u]].u;
		}
	}
}

void solve() {
	scanf("%d%d%d%d", &n, &m, &s, &t);
	inc(i, 1, m) {
		int u, v, w, f;
		scanf("%d%d%d%d", &u, &v, &w, &f);
		addPair(u, v, w, f);
	}
	MCMF();
	printf("%d %d", maxF, minC);
}

int main() {
	solve();
	return 0;
}
```
``` c
/*
prim
loj-10066
*/
#include<queue>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=300+5;
const int maxm=(1<<10)+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

int n,g[maxn][maxn],dis[maxn],vis[maxn];

int prim(){
	int ans=0;
	memset(dis,0x3f,sizeof(dis));
	priority_queue< pair<int,int> >q;
	q.push(make_pair(0,1));
	dis[1]=0;
	while(!q.empty()){
		int now=q.top().second;q.pop();
		if(vis[now])continue;
		vis[now]=1;
		ans+=dis[now];
		for(int i=1;i<=n+1;i++){
			if(vis[i])continue;
			if(g[now][i]<dis[i]){
				dis[i]=g[now][i];
				q.push(make_pair(-dis[i],i));
			}
		}
	}
	return ans;
}

void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&g[i][n+1]),g[n+1][i]=g[i][n+1];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&g[i][j]);
	printf("%d",prim());	
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
原题来自：BeiJing 2010 组队赛

给定一张N个点M条边的无向图，求无向图的严格次小生成树。

设最小生成树的边权之和为 ，严格次小生成树就是指边权之和大于  的生成树中最小的一个。

次小生成树 kruskal lca
*/
#include<bits/stdc++.h>
#define lson p<<1
#define rson p<<1|1
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef set<int>::iterator it;
const int inf=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=3e5+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

struct edge{
	int v,w,next;
}es[2*maxn];
struct oedge{
	int u,v,w;
	bool operator<(const oedge & a)const{return w<a.w;}
}edges[maxm];
int n,m,head[maxn],tot,ff[maxn],fa[maxn][25],g[maxn][25][2],vis[maxm],dep[maxn],lg[maxn];
ll ans,nans;

int read(){
	int res=0,f=1;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())res=res*10+ch-'0';
	return res*f;
}

inline void addEdge(int u,int v,int w){
	es[++tot].v=v,es[tot].w=w,es[tot].next=head[u],head[u]=tot;
}

int find(int x){
	return (ff[x]==x)?x:(ff[x]=find(ff[x]));
}

void kruskal(){
	for(int i=1;i<=n;i++)ff[i]=i;
	sort(edges+1,edges+m+1);
	for(int j=0,i=1;i<=m;i++){
		int u=edges[i].u,v=edges[i].v,w=edges[i].w;
		int uf=find(u),vf=find(v);
		if(uf!=vf){
			vis[i]=1;
			ans+=w;
			++j;
			ff[uf]=vf;
			addEdge(u,v,w),addEdge(v,u,w);
			if(j==n-1)break;
		}
	}
}

void dfs(int u,int f){
	dep[u]=dep[f]+1;
	for(int i=1;(1<<i)+1<=dep[u];i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=1;(1<<i)+1<=dep[u];i++)g[u][i][0]=max(g[u][i-1][0],g[fa[u][i-1]][i-1][0]);
	for(int i=1;(1<<i)+1<=dep[u];i++){
		if(g[u][i-1][0]==g[fa[u][i-1]][i-1][0])g[u][i][1]=max(g[u][i-1][1],g[fa[u][i-1]][i-1][1]);
		else if(g[u][i-1][0]<g[fa[u][i-1]][i-1][0])g[u][i][1]=max(g[u][i-1][0],g[fa[u][i-1]][i-1][1]);
		else if(g[u][i-1][0]>g[fa[u][i-1]][i-1][0])g[u][i][1]=max(g[u][i-1][1],g[fa[u][i-1]][i-1][0]);
	}
	for(int i=head[u];i;i=es[i].next){
		int v=es[i].v,w=es[i].w;
		if(f==v)continue;
		fa[v][0]=u;
		g[v][0][0]=w;
		g[v][0][1]=-1;
		dfs(v,u);
	}
}

int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=lg[dep[x]-dep[y]];i>=0;i--){
		if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
		if(x==y)return x;
	}
	for(int i=lg[dep[x]-1];i>=0;i--){
		if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}

inline void upd(int & max1,int &max2,int x,int i){
	if(max1==g[x][i][0])max2=max(max2,g[x][i][1]);
	else if(max1<g[x][i][0])max2=max(max1,g[x][i][1]);
	else if(max1>g[x][i][0])max2=max(max2,g[x][i][0]);
	max1=max(max1,g[x][i][0]);
}

inline void updMax(int x,int y,int &max1,int &max2){
	for(int i=lg[dep[x]-dep[y]];i>=0;i--){
		if(dep[fa[x][i]]>=dep[y]){
			upd(max1,max2,x,i);
			x=fa[x][i];
		}
		if(x==y)break;
	}
}

void test(int x,int y,int id){
	int z=lca(x,y),xmax1=0,xmax2=0,ymax1=0,ymax2=0;
	updMax(x,z,xmax1,xmax2);
	updMax(y,z,ymax1,ymax2);
	int max1,max2;
	max1=max(xmax1,ymax1);
	if(xmax1==ymax1)max2=max(xmax2,ymax2);
	else if(xmax1<ymax1)max2=max(xmax1,ymax2);
	else if(xmax1>ymax1)max2=max(xmax2,ymax1);
	int w=edges[id].w;
	if(max1==w)nans=min(nans,ans-max2+w);
	else if(max1<w)nans=min(nans,ans-max1+w);
}

void solve(){
	n=read(),m=read();
	int x,y,z;
	for(int i=1;i<=m;i++)edges[i].u=read(),edges[i].v=read(),edges[i].w=read(),nans+=edges[i].w;
	kruskal();
	lg[0]=-1;
	for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
	dfs(1,0);
	for(int i=1;i<=m;i++){
		if(vis[i]||edges[i].u==edges[i-1].u&&edges[i].v==edges[i-1].v)continue;
		int x=edges[i].u,y=edges[i].v;
		test(x,y,i);
	}
	printf("%lld",nans);
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
筛法
*/

//欧拉函数
void phi_table(int n, int* phi) {
  for (int i = 2; i <= n; i++) phi[i] = 0;
  phi[1] = 1;
  for (int i = 2; i <= n; i++)
    if (!phi[i])
      for (int j = i; j <= n; j += i) {
        if (!phi[j]) phi[j] = j;
        phi[j] = phi[j] / i * (i - 1);
      }
}

//莫比乌斯函数
void pre() {
  mu[1] = 1;
  for (int i = 2; i <= 1e7; ++i) {
    if (!v[i]) mu[i] = -1, p[++tot] = i;
    for (int j = 1; j <= tot && i <= 1e7 / p[j]; ++j) {
      v[i * p[j]] = 1;
      if (i % p[j] == 0) {
        mu[i * p[j]] = 0;
        break;
      }
      mu[i * p[j]] = -mu[i];
    }
  }
  
  
//约数个数  
void pre() {
  d[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) v[i] = 1, p[++tot] = i, d[i] = 2, num[i] = 1;
    for (int j = 1; j <= tot && i <= n / p[j]; ++j) {
      v[p[j] * i] = 1;
      if (i % p[j] == 0) {
        num[i * p[j]] = num[i] + 1;
        d[i * p[j]] = d[i] / num[i * p[j]] * (num[i * p[j]] + 1);
        break;
      } else {
        num[i * p[j]] = 1;
        d[i * p[j]] = d[i] * 2;
      }
    }
  }
}



//约数和
void pre() {
  g[1] = f[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) v[i] = 1, p[++tot] = i, g[i] = i + 1, f[i] = i + 1;
    for (int j = 1; j <= tot && i <= n / p[j]; ++j) {
      v[p[j] * i] = 1;
      if (i % p[j] == 0) {
        g[i * p[j]] = g[i] * p[j] + 1;
        f[i * p[j]] = f[i] / g[i] * g[i * p[j]];
        break;
      } else {
        f[i * p[j]] = f[i] * f[p[j]];
        g[i * p[j]] = 1 + p[j];
      }
    }
  }
  for (int i = 1; i <= n; ++i) f[i] = (f[i - 1] + f[i]) % Mod;
}
```
``` c
/*
st表
loj-10119
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e5+5;
const int maxm=1e6+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

int n,m,lg[maxn],a[maxn],f[maxn][25];

int read(){
	int ans=0,f=1;
	char ch=getchar();
	for(;ch<'0'||ch>'9';){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	for(;ch>='0'&&ch<='9';)ans=ans*10+ch-'0',ch=getchar();
	return ans*f;
}



void init(){
	for(int i=1;i<=n;i++)f[i][0]=a[i];
	for(int i=1;(1<<i)<=n;i++){
		for(int j=1;j+(1<<i)-1<=n;j++){
			f[j][i]=max(f[j][i-1],f[j+(1<<i-1)][i-1]);
		}
	}
}

void solve(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)a[i]=read();
	lg[0]=-1;
	for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
	init();
	while(m--){
		int x,y;
		x=read(),y=read();
		int z=lg[y-x+1];
		printf("%d\n",max(f[x][z],f[y-(1<<z)+1][z]));
	}
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```

``` c
/*
tarjan
缩点
loj-10091
*/

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf=0x3f3f3f3f;
const int maxn=1e4+5;
const int maxm=5e4+5;
const double eps=1e-10;
const int base=131;
const int mod=1e9+7;

struct edge{
	int v,next;
}es[maxm];
int n,m,tot,head[maxn],cnt,dfn[maxn],low[maxn],instack[maxn],cc,col[maxn],colcnt[maxn],outd[maxn];
stack<int>s;

inline void addEdge(int u,int v){
	es[++tot].v=v,es[tot].next=head[u],head[u]=tot;
}

void tarjan(int x){
	dfn[x]=low[x]=++cnt;
	s.push(x);
	instack[x]=1;
	for(int i=head[x];i;i=es[i].next){
		int v=es[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}else if(instack[v]){
			low[x]=min(low[x],dfn[v]);
		}
	}
	if(dfn[x]==low[x]){
		int crt;
		cc++;
		do{
			crt=s.top();s.pop();
			instack[crt]=0;
			col[crt]=cc;
			colcnt[cc]++;
		}while(crt!=x);
	}
}

void solve(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		addEdge(a,b);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i<=n;i++)for(int j=head[i];j;j=es[j].next)if(col[i]!=col[es[j].v])outd[col[i]]++;//如何统计出度qwq
	int num=0,cp;
	for(int i=1;i<=cc;i++)if(!outd[i])cp=i,num++;
	if(num==1)printf("%d",colcnt[cp]);
	else puts("0");
}

int main(){
//	freopen("in.txt","r",stdin);
	solve();
	return 0;
}
```
``` c
/*
拓扑排序
*/

void topoSort() {
	while (Q.size()) {
		int u = Q.front(); Q.pop();
		for (int i = head[u]; i; i = es[i].next) {
			int v = es[i].v;
			if (--ind[v] == 0) Q.push(v), cnt2++;
		}
	}
}
```
``` c
/*
动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 
现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 
有人用两种说法对这N个动物所构成的食物链关系进行描述： 
第一种说法是"1 X Y"，表示X和Y是同类。 
第二种说法是"2 X Y"，表示X吃Y。 
此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 
1） 当前的话与前面的某些真的话冲突，就是假话； 
2） 当前的话中X或Y比N大，就是假话； 
3） 当前的话表示X吃X，就是假话。 
你的任务是根据给定的N（1 <= N <= 50,000）和K句话（0 <= K <= 100,000），输出假话的总数。 

带权并查集 种类并查集 板子
一个连通块内的关系是确定的，不同的连通块关系不确定
一个连通块的fa的rank为0...
*/
#include<cstdio>
#include<cctype>
using namespace std;

typedef long long ll;

const int MAXN=5e4+10;
const int MAXM=30;
const int INF=0x3f3f3f3f;

int n,k,ans,fa[MAXN],rank[MAXN];

int read(){
	int res=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
	for(;isdigit(ch);ch=getchar())res=res*10+ch-'0';
	return res*f;
}

inline void init(){
	for(int i=1;i<=n;i++)fa[i]=i;
}

int getFa(int x){
	if(x==fa[x])return x;
	int pf=fa[x];
	fa[x]=getFa(fa[x]);
	rank[x]=(rank[x]+rank[pf])%3;
	return fa[x];
}

bool check(int x,int y,int d){
	int xf=getFa(x),yf=getFa(y);
	if(xf==yf){
		if((rank[x]+d)%3==rank[y])return 0;
		else return 1;
	}
	fa[yf]=xf;
	rank[yf]=((d-rank[y])%3+3+rank[x])%3;
	return 0;
}

void solve(){
	scanf("%d%d",&n,&k);
	init();
	while(k--){
		int d,x,y;
		d=read(),x=read(),y=read();
		if(x==y&&d==2)++ans;
		else if(x>n||y>n)++ans;
		else if(check(x,y,d-1))++ans;
	}
	printf("%d",ans);
}

int main(){
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	solve();
	return 0;
}
```
## pb_ds
来自[洛谷日报第39期]
### 头文件
``` c
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>//用tree
#include<ext/pb_ds/hash_policy.hpp>//用hash
#include<ext/pb_ds/trie_policy.hpp>//用trie
#include<ext/pb_ds/priority_queue.hpp>//用priority_queue
using namespace __gnu_pbds;
```
或者
``` c
#include<bits/extc++.h>
using namespace __gnu_pbds;
//bits/extc++.h与bits/stdc++.h类似，bits/extc++.h是所有拓展库，bits/stdc++.h是所有标准库
```
### hash
复杂度O(1)
``` c
cc_hash_table<int,bool> h; //拉链法
gp_hash_table<int,bool> h; //探测法，更快
```
``` c
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
gp_hash_table<string,int> h;
void judge(string s)
{
    if(h.find(s)!=h.end())
        cout<<"orz %%%";
    else
        cout<<"tan90";
    cout<<endl;
}
int main()
{
    h["Ican'tAKIOI"]=1;
    h.insert(make_pair("UAKIOI",1));
    string str;
    while(cin>>str)
        judge(str);
    return 0;
}
```
### tree
pbds里面的tree都是平衡树，其中有rb_tree,splay_tree,ov_tree（后两种都容易超时，所以请不要用它们）。
``` c
#define pii pair<int,int>
#define mp(x,y) make_pair(x,y) 
tree<pii,null_type,less<pii>,rb_tree_tag,tree_order_statistics_node_update> tr;
pii //存储的类型
null_type //无映射(低版本g++为null_mapped_type)
less<pii> //从小到大排序
rb_tree_tag //红黑树
tree_order_statistics_node_update //更新方式 
tr.insert(mp(x,y)); //插入;
tr.erase(mp(x,y)); //删除;
tr.order_of_key(pii(x,y)); //求排名 
tr.find_by_order(x); //找k小值，返回迭代器 
tr.join(b); //将b并入tr，前提是两棵树类型一样且没有重复元素 
tr.split(v,b); //分裂，key小于等于v的元素属于tr，其余的属于b
tr.lower_bound(x); //返回第一个大于等于x的元素的迭代器
tr.upper_bound(x); //返回第一个大于x的元素的迭代器
//以上所有操作的时间复杂度均为O(logn) 
```
**洛谷P3369 普通平衡树**

您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1.插入xx数

2.删除xx数(若有多个相同的数，因只删除一个)

3.查询xx数的排名(排名定义为比当前数小的数的个数+1+1。若有多个相同的数，因输出最小的排名)

4.查询排名为xx的数

5.求xx的前驱(前驱定义为小于xx，且最大的数)

6.求xx的后继(后继定义为大于xx，且最小的数)
``` c
//by shenben
#include<cstdio>
#include<iostream>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> bbt;
int n;ll k,ans;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
} 
int main(){
    n=read();
    for(int i=1,opt;i<=n;i++){
        opt=read();k=read();
        if(opt==1) bbt.insert((k<<20)+i);
        if(opt==2) bbt.erase(bbt.lower_bound(k<<20));
        if(opt==3) printf("%d\n",bbt.order_of_key(k<<20)+1);
        if(opt==4) ans=*bbt.find_by_order(k-1),printf("%lld\n",ans>>20);
        if(opt==5) ans=*--bbt.lower_bound(k<<20),printf("%lld\n",ans>>20);
        if(opt==6) ans=*bbt.upper_bound((k<<20)+n),printf("%lld\n",ans>>20);
    }
    return 0;
}
```
### trie
``` c
typedef trie<string,null_type,trie_string_access_traits<>,pat_trie_tag,trie_prefix_search_node_update> tr;
//第一个参数必须为字符串类型，tag也有别的tag，但pat最快，与tree相同，node_update支持自定义
tr.insert(s); //插入s 
tr.erase(s); //删除s 
tr.join(b); //将b并入tr 
pair//pair的使用如下：
pair<tr::iterator,tr::iterator> range=base.prefix_range(x);
for(tr::iterator it=range.first;it!=range.second;it++)
    cout<<*it<<' '<<endl;
//pair中第一个是起始迭代器，第二个是终止迭代器，遍历过去就可以找到所有字符串了。 
```

### priority_queue
``` c
priority_queue<int,greater<int>,TAG> Q;//小根堆，大根堆写less<int>
/*其中的TAG为类型，有以下几种：
pairing_heap_tag
thin_heap_tag
binomial_heap_tag
rc_binomial_heap_tag 
binary_heap_tag
其中pairing_help_tag最快*/
Q.push(x);
Q.pop();
Q.top();
Q.join(b);
Q.empty();
Q.size(); 
Q.modify(it,6);
Q.erase(it);
//以上操作我都不讲了，pbds里的优先队列还可以用迭代器遍历
```
时间复杂度：

*pairing_heap_tag:push和join为O（1），其余为均摊Θ（logn）

*binary_heap_tag：只支持push和pop，均为均摊Θ（logn）

*binomial_heap_tag:push为均摊O（1），其余为Θ（logn）

*rc_binomial_heap_tag:push为O（1），其余为Θ（logn）

*thin_heap_tag:push为O（1），不支持join，其余为Θ（logn）；但是如果只有increase-key，那么modify为均摊O（1）



## 注意

过样例，提交前检查：
1. 数据范围
2. 数据类型，包括定义和输入输出
3. 初始化
4. freopen关掉
5. 是否多组样例
6. 提交时选对语言qwq，java注意package


来自xgsteins：
1. %I64d与%lld
2. !=EOF 或者 == n 需要测试
3. 流同步关闭后不能混用cin、cout与scanf、printf